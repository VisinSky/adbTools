name: Build Signed adbTools APK (Auto Generate Keystore)

on:
  workflow_dispatch: # 仅手动触发
  push:
    branches: [ main ]
    paths-ignore: [ "keystore_info.txt" ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      # 基础配置
      KEY_ALIAS: myadbkey
      KEYSTORE_FILE: ./keystore.jks
      CERT_DNAME: "CN=adbTools, OU=GitHubActions, O=VisinSky, L=Unknown, ST=Unknown, C=CN"
      KEY_INFO_FILE: keystore_info.txt
      # Android SDK 配置
      ANDROID_HOME: /usr/local/lib/android/sdk
      ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
      BUILD_TOOLS_VERSION: 33.0.2
      ANDROID_PLATFORM_VERSION: android-33

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      # 手动安装Android SDK（稳定无兼容问题）
      - name: Manually install Android SDK components
        run: |
          export PATH=$ANDROID_HOME/cmdline-tools/latest/bin:$PATH
          echo "y" | sdkmanager --licenses || true
          echo "y" | sdkmanager "platform-tools" "platforms;${ANDROID_PLATFORM_VERSION}" "build-tools;${BUILD_TOOLS_VERSION}"
          echo "✅ Android SDK 安装完成，已安装组件："
          sdkmanager --list_installed

      # 判断Secrets是否存在，输出标记变量
      - name: Check if keystore secrets exist
        id: check_secrets
        run: |
          if [ -z "${{ secrets.KEYSTORE_BASE64 }}" ] || [ "${{ secrets.KEYSTORE_BASE64 }}" = "" ]; then
            echo "is_first_run=true" >> $GITHUB_OUTPUT
            echo "✅ 检测到无密钥Secrets，将执行首次生成逻辑"
          else
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "✅ 检测到密钥Secrets，将执行还原签名逻辑"
          fi

      # 首次运行生成新密钥
      - name: Generate Keystore (First Run Only)
        if: ${{ steps.check_secrets.outputs.is_first_run == 'true' }}
        run: |
          # 生成随机16位密码
          KEYSTORE_PASSWORD=$(openssl rand -hex 8)
          KEY_PASSWORD=$KEYSTORE_PASSWORD
          
          # 非交互生成密钥库
          keytool -genkey -v \
            -keystore $KEYSTORE_FILE \
            -alias $KEY_ALIAS \
            -keyalg RSA \
            -keysize 2048 \
            -validity 10000 \
            -dname "$CERT_DNAME" \
            -storepass $KEYSTORE_PASSWORD \
            -keypass $KEY_PASSWORD \
            -noprompt
          
          # 密钥库转Base64编码
          KEYSTORE_BASE64=$(base64 -w 0 $KEYSTORE_FILE)
          
          # 写入信息到文本文件
          echo "=== adbTools 密钥库信息（请妥善保管，配置完Secrets后删除此文件）===" > $KEY_INFO_FILE
          echo "KEY_ALIAS: $KEY_ALIAS" >> $KEY_INFO_FILE
          echo "KEYSTORE_PASSWORD: $KEYSTORE_PASSWORD" >> $KEY_INFO_FILE
          echo "KEY_PASSWORD: $KEY_PASSWORD" >> $KEY_INFO_FILE
          echo "KEYSTORE_BASE64: $KEYSTORE_BASE64" >> $KEY_INFO_FILE
          
          # 临时保存到环境变量
          echo "KEYSTORE_PASSWORD=$KEYSTORE_PASSWORD" >> $GITHUB_ENV
          echo "KEY_PASSWORD=$KEY_PASSWORD" >> $GITHUB_ENV
          echo "KEYSTORE_BASE64=$KEYSTORE_BASE64" >> $GITHUB_ENV

      # 后续运行读取Secrets还原密钥库
      - name: Restore Keystore from Secrets (Subsequent Runs)
        if: ${{ steps.check_secrets.outputs.is_first_run == 'false' }}
        run: |
          # 从Secrets读取Base64并还原密钥库文件
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > $KEYSTORE_FILE
          
          # 读取密码到环境变量
          echo "KEYSTORE_PASSWORD=${{ secrets.KEYSTORE_PASSWORD }}" >> $GITHUB_ENV
          echo "KEY_PASSWORD=${{ secrets.KEY_PASSWORD }}" >> $GITHUB_ENV

      # 提交密钥信息文件到仓库（仅首次运行）
      - name: Commit Keystore Info to Repo
        if: ${{ steps.check_secrets.outputs.is_first_run == 'true' }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add $KEY_INFO_FILE
          git commit -m "chore: add keystore info file (auto-generated)"
          git push origin main
          echo "✅ 密钥信息文件已提交到仓库，请立即查看并配置Secrets，配置完成后删除此文件！"

      # 生成自动版本号
      - name: Generate version info
        id: version
        run: |
          echo "VERSION_NAME=1.0.${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "VERSION_CODE=${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "TAG_NAME=v1.0.${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      # 构建 + 签名（核心修复：适配sign-android-release参数） + 上传 + 发布
      - name: Grant execute permission to gradlew
        run: chmod +x gradlew

      - name: Build unsigned Release APK
        run: ./gradlew assembleRelease -PversionName=${{ env.VERSION_NAME }} -PversionCode=${{ env.VERSION_CODE }} --no-daemon

      # 修复签名步骤：移除无效参数，改用signingKeyBase64传递密钥库
      - name: Sign APK
        id: sign_apk
        uses: r0adkll/sign-android-release@v1
        with:
          releaseDirectory: app/build/outputs/apk/release
          # 核心修改：用signingKeyBase64替代keyStoreFile（该Action的标准用法）
          signingKeyBase64: ${{ env.KEYSTORE_BASE64 || secrets.KEYSTORE_BASE64 }}
          alias: ${{ env.KEY_ALIAS }}
          keyStorePassword: ${{ env.KEYSTORE_PASSWORD }}
          keyPassword: ${{ env.KEY_PASSWORD }}
          # 移除无效的buildToolsVersion参数

      - name: Rename signed APK
        run: |
          mv ${{ steps.sign_apk.outputs.signedReleaseFile }} app/build/outputs/apk/release/adbTools-v${{ env.VERSION_NAME }}-signed.apk

      - name: Upload signed APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: adbTools-signed-apk-v${{ env.VERSION_NAME }}
          path: app/build/outputs/apk/release/adbTools-v${{ env.VERSION_NAME }}-signed.apk

      - name: Release to GitHub
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG_NAME }}
          files: app/build/outputs/apk/release/adbTools-v${{ env.VERSION_NAME }}-signed.apk
          draft: false
          prerelease: false
          name: adbTools v${{ env.VERSION_NAME }} (Signed)
